### 1. Locations
    'LocationName     Halting location.
    ''LocationName    Non-halting location.
    '''LocationName   Location that may be either halting, or non-halting.
    *Location         Halting location (Non-virtual - test context only).
    **Location        Non-halting location (Non-virtual - test context only).
    ***Location       Location that may be either halting, or non-halting (Non-virtual - test context only).

Location placeholders denote a storage area where categories, quantities, and/or services can be stored - they can be read from and/or written to from within an intersection operation.

Locations can be defined as halting or non-halting (to enable continuous reading) - only a service's input location may be declared to support both halting and non-halting locations. For example:

    ('''Word: 'T)(import: 'Import)(export: 'Export)(Service: 'C and 'D)

Readers of non-halting locations may only be used as arguments to service calls.

In a test context, locations may be tagged as non-virtual, so they may perform
input-output when test binary is executed.

Unlike category and service placeholders, locations can only be used after they are defined - this is done to prevent services from forming circular references using locations.

Within a service, input location may be used in body to refer to current input being processed by service.

A 'main' location denoted (') is entry point for an application - when read from, it outputs quantities of type 'intmin' supplied by user on command line. Services referenced with 'main' location as input location must finish running before any other service is run. There can only be a single service that takes a reader from 'main' as an argument. For example:

    Service(read Chr from ')(import)(export: 'Export)

Compiler checks reads from locations to ensure they always contain a value at the time they are read - implementation-hidden services give caller data about whether a location is empty or not to avoid needing to reveal implementation.

### 2. Readers and writers
    write 'Export to 'Location else 'MemFull      Writer.
    add 'Item to 'Location else 'MemFull          Writer (Push operation).
    read 'Import from 'Location else 'MemFull     Reader.

Readers and writers are used to store and retrieve categories, quantities, and/or services from memory - they are what enables all input-output operations, and concurrent communication between two or more services to work in the language.

Writers capture structure and write it to a specific location that is either defined in-place, or an existing location. Readers insert a category existing at a particular location, fitting it inside reader's body category within an intersection. Writers only execute after intersection it's inside of is solved.

Writers that end up a member of a union that contains at least one other writer after intersection are not run, since it is unclear which writers are intended to be executed and not.

Readers are not capable of defining new locations, since the created location would be created empty, then immediately read from.

Both have a clause to enable developers to handle cases where location and/or structure memory limit is reached - this clause must be denoted with a single (') in order to skip.

### 3. Implementation hiding
    ['T]('Word: 'T)(import: 'Import)(export: 'Export)(Service)  Service declaration.
    ['T](Category: 'Constraint)                                 Category declaration.

Language supports usage of binary code with headers - the implementation of a service and/or category not revealed in this case. The user has access to information about accepted inputs, locations imported from, data stored at exported locations, and respective restraints on import and export locations for services. Whether an exported location is empty or not is also shared. If implementation of a service is not available, it cannot be intersected, since body is required to do this.

For category definitions, category body in implementation must be an instance of category body in header, so user has access to output structure, with some information about specific category structures redacted, if needed.

### 4. Application binary interface

Binaries generated by compilers must be tagged with a unique compiler identifier - this ensures that only compatible binaries may be linked unless explicitly requested by developer.

